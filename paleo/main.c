/*
LibAndria version 4
A C-based general purpose utility library.
Copyright (c) 2025 Jared A. Maddox

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

This grant of rights is subject to two conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

And:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/* What follows most immediately (continuing into main() itself) is */
/*  essentially an attempt to setup an overlay of types defined in arbitrary */
/*  source files into the same space within an object file, and then measure */
/*  the size of the resulting area, and pass that size back to the code as a */
/*  value that can then be used to control allocation of memory for arbitrary */
/*  purposes. */
/* ... I want that generified. I PARTICULARLY want to generify it to support */
/*  pre-allocating per-thread space to store arbitrary data for exception */
/*  handling, but I REALLY want to generify it for any particular use. I've */
/*  already determined that my first idea (measuring the sizes of the */
/*  sections separately in code, selecting the max, and inserting that */
/*  "manually" into an output object file) was the idea, and determined the */
/*  correct one instead (place a symbol, place the various overlays, then */
/*  place a second symbol and emit the result of subtracting the first symbol */
/*  from the second), as well as caveats in that process (the obvious way to */
/*  do it doesn't overlay things at all, but instead places them */
/*  sequentially, so the linker script itself needs to be generated by a */
/*  non-linker script in whatever shell script is convenient). What remains */
/*  is to verify the ability to do this in the remaining "interesting" */
/*  systems (at least I want to target MSVC, maybe Intel's compiler, whatever */
/*  gets used on the various BSDs, preferably whatever non-GCC option is used */
/*  for PIC microcontrollers, something DOS, maybe something CPM), figure out */
/*  the details for them (at least some stuff based of COFF won't be usable, */
/*  so support will need to force e.g. GCC anyways), then produce the */
/*  generified macros & shell scripts (which ideally should be in a */
/*  platform-support Makefile, for modularity+convenience). */
/*  ... And then I need to rework the corogate stuff to use that generic */
/*  facility. Note that corogate should REALLY be "quickly" switching back to */
/*  *_coronext(), which itself should be calling into the desired code, with */
/*  *_coroyield() taking a closure value... but then will I even need all the */
/*  longjump() stuff? Regardless, the object-section stuff will be desired. */
/*  Also, it'll be desirable to define seperate "coroutine sets" so that */
/*  calling yield() in the A(), B(), C() set won't interfere with the x(), */
/*  y(), z() set. That MIGHT make the longjump() stuff useful. */
/*  ... And THEN I need to build a resume-supporting exception- throw/catch */
/*  system around it as well (because coroutines are certainly a sensible */
/*  user, but also certainly not the only sensible user). */
/*  THEN I need to decide if I want to be able to implement DGD-link */
/*  "blueprint" object-members with this as well, which may have some */
/*  ultimate implications about whether the linker-overlay object-section */
/*  should or shouldn't be pruned before the final executable is produced. */
/*  Oh! Also, I need to make it usable as a signal-wrapping system! */
/*  Another "Oh!", a setjump()/longjump() wrapper that supports AT LEAST a */
/*  uintptr_t/intptr_t, and preferably a maybe of two copies of whichever, to */
/*  fix that Sun Microsystems mistake from the 80's. */
#include <setjmp.h>

typedef struct libandria4_corogate
{
  jmp_buf callee, caller;
  
} libandria4_corogate;

typedef struct libandria4_coroclosure libandria4_coroclosure;
typedef void (*libandria4_corofunc)( void* );
struct libandria4_coroclosure
{
	libandria4_corofunc f;
	void *arg;
};
#define LIBANDRIA4_BUILDCOROCLOSURE( f, arg ) \
	(libandria4_coroclosure){ ( f ), ( arg ) }

	/* framnesize might be 5... or it might not. Dig deeper. */
void libandria4_corostart
(
	libandria4_corogate* c,
		/* The size allocated for newstack. */
	size_t stacksize,
	void* newstack,
		/* I'm not sure what this is, the examples seem too small for frame-pointer + stack-pointer? */
	size_t framesize,
	
		/* The function/argument pair for invocation. */
	libandria4_coroclosure cls
);
void libandria4_coroyield( libandria4_corogate* c );
int libandria4_coronext( libandria4_corogate* c );





/* A header include for the stuff defined above should exist around here. */
/* Also note: look at wrapping C++20's co_await stuff. */

/* GCC defines __USER_LABEL_PREFIX__ as a macro that translates to a token */
/*  that's used as the prefix applied to the symbols visible in C, to */
/*  translate them into assembly. */
/* MSVC defines __FUNCDNAME__ , which is the ENTIRE name. */

#if 1
	#define LIBANDRIA4_GETSP( p ) \
	  asm volatile("movq %%rsp, %0" : "=r"(p))
	#define LIBANDRIA4_GETFP( p ) \
	  asm volatile("movq %%rbp, %0" : "=r"(p))
	#define LIBANDRIA4_SETSP( p ) \
	  asm volatile("movq %0, %%rsp" : : "r"(p))
	#define LIBANDRIA4_SETFP( p ) \
	  asm volatile("movq %0, %%rbp" : : "r"(p))
	
	
	const size_t stackgrain = sizeof( void* );
	
	
	enum
	{
		libandria4_coroworking = 1,
		libandria4_corodone
	};
	
	typedef struct libandria4_coro_startparams
	{
	  libandria4_corogate* c;
	  libandria4_coroclosure cls;
	  void* old_sp;
	  void* old_fp;
	  
	} libandria4_coro_startparams;
	
	
	void libandria4_coroyield( libandria4_corogate* c )
	{
		if( !setjmp( c->callee ) )
		{
				/* Gets tested in libandria4_coronext(). */
			longjmp( c->caller, libandria4_coroworking );
		}
	}
	
	int libandria4_coronext( libandria4_corogate* c )
	{
		int ret = setjmp( c->caller );
		if( !ret )
		{
				/* Gets tested in start() once, and afterwards in libandria4_coroyield(). */
			longjmp( c->callee, 1 );
			
		} else {
			
			return ret == libandria4_coroworking;
		}
	}
	
	
	
	
	
	
	/*
		Review these:
			https://fanf.livejournal.com/105413.html
			http://dotat.at/cgi/git/picoro.git
	*/
	void start
	(
		libandria4_corogate* c,
		size_t stacksize, void* newstack,
		size_t framesize,
		
		libandria4_coroclosure cls
	)
	{
		libandria4_coro_startparams* p =
			(
				(libandria4_coro_startparams*)
				(
						/* If the stack grows up, then this needs */
						/*  to be subtraction instead. */
					(char*)newstack +
					stacksize
				)
			) - 1;
		
		//save params before stack switching
		p->c = c;
		p->cls = cls;
		LIBANDRIA4_GETSP( p->old_sp );
		LIBANDRIA4_GETFP( p->old_fp );
		
		LIBANDRIA4_SETSP( p - framesize );
		LIBANDRIA4_SETFP( p ); //effectively clobbers p
			//(and all other locals)
		LIBANDRIA4_GETFP( p ); //...so we read p back from $fp
		
		//and now we read our params from p
		if( !setjmp( p->c->callee ) )
		{
			/* We just finished configuration, return to caller. */
			
			LIBANDRIA4_SETSP( p->old_sp );
			LIBANDRIA4_SETFP( p->old_fp );
			return;
		}
		while( p->cls.f )
		{
			p->cls = ( *(p->cls.f) )( p->cls.arg );
		}
			/* Gets tested in libandria4_coronext(), causing it to return */
			/*  0, which SHOULD end invocation. */
		longjmp( p->c->caller, libandria4_corodone );
	}
#endif

/* This file exists to setup some things for other systems. Right now it */
/*  only attempts to pre-allocate an artificial stack-frame for exception */
/*  handling, but later it will likely do other tasks as well. It */
/*  ABSOLUTELY needs some header includes added. */





#if 0
	/* GNU LD version. */
	
	/* The following is a shell script that SHOULD produce the needed GNU */
	/*  ld script. Note that e.g. filenames including newline shouldn't be */
	/*  used, because they won't work... and are also genuinely bad ideas. */
	/*
		files=./*.o
		echo "SECTION : {"
		echo "    _libandria4_main_corostart = .;"
		echo "    OVERLAY : NOCROSSREFS {"
		for entry in $files; do
			echo -n "    "
				echo -n "$entry"
				echo -n " { "
				echo -n "$entry"
				echo "(LIBANDRIA4_CORO_MAINALLOC_OVR) }"
		done
		echo "    },"
		echo "    _libandria4_main_coroend = .;"
		echo "    .data { "
		echo "        _libandria4_main_corosize = .;"
		echo "        LONG( _libandria4_main_coroend - _libandria4_main_corostart )"
		echo "    }"
		echo "}"
		echo "INSERT AFTER .data;"
	*/
	
	/* GCC version, seems to be supported by Clang and TCC too. Kefir */
	/*  supports at least __attribute__, but I didn't find info for lcc or */
	/*  chibicc. cproc and simple-cc seemn likely to lack needed features */
	/*  for this. */
	struct
	{
		libandria4_coro_startparams stpm;
		
	} libandria4_coro_mainalloc __attribute__ ((section ("LIBANDRIA4_CORO_MAINALLOC_OVR"))) =
		{ 0 };
#elif 0
	/* MSVC version. */
	#pragma section( "LIBANDRIA4_CORO_MAINALLOC_OVR",read,write )
	__declspec(allocate("LIBANDRIA4_CORO_MAINALLOC_OVR" )) struct
		{
			libandria4_coro_startparams stpm;
			
		} libandria4_coro_mainalloc = { 0 };
#else
	#error "LibAndria4's main.c isn't ready, don't use it yet."
#endif



extern int libandria4_main( int, char** );
extern const uint32_t libandria4_main_corosize;

int main( int argn, char *args[] )
{
	libandria4_corogate cgate;
	
	if( libandria4_main_corosize > ??? )
	{
			/* Stack overflow predicted, so "crash out" instead. */
		??? ;
	}
	
		/* Get our exception stack allocated. */
	#if
			/* An "artificially" allocated stack for exception-handling. It */
			/*  SPECIFICALLY exists to be used for a coroutine-based */
			/*  "not-yet-fatal" set of cases, none of which have been */
			/*  prepared for yet... or identified. In particular, it's meant */
			/*  to work even if the stack cannot grow anymore. */
		char excep_stack_
			[
				libandria4_main_corosize +
				stackgrain +
				sizeof( libandria4_coro_startparams )
			];
		char *excep_stack = excep_stack_;
	#else
		char *excep_stack = (char*)alloca( libandria4_main_corosize );
	#else
		/* Microsoft versions. */
		
		if
		(
			libandria4_main_corosize +
				stackgrain +
				sizeof( libandria4_coro_startparams ) >
			_ALLOCA_S_THRESHOLD
		)
		{
				/* Size too big, error out. */
			??? ;
		}
		char *excep_stack;
		__try
		{
		#if
				/* Old version. */
			excep_stack =
				(char*)_alloca
				(
					libandria4_main_corosize +
					stackgrain +
					sizeof( libandria4_coro_startparams )
				);
		#else
				/* New version. */
			excep_stack =
				(char*)_malloca
				(
					libandria4_main_corosize +
					stackgrain +
					sizeof( libandria4_coro_startparams )
				);
		#endif
		}
		__except( GetExceptionCode() == STATUS_STACK_OVERFLOW )
		{
			/* Stack overflow. */
			
				/* We */
			if( _resetstkoflw() == 0 )
			{
				/* Stack couldn't be restored, but we're erroring out */
				/*  regardless, so it doesn't matter. */
				
			} else {
			}
			??? ;
		}
	#endif
	if( !excep_stack )
	{
			/* Allocation failed, crash out. */
		??? ;
	}
	
	start
	(
		&cgatec,
		
		libandria4_main_corosize +
			stackgrain +
			sizeof( libandria4_coro_startparams )
		(void*)excep_stack,
		
		size_t framesize,
		
		
		LIBANDRIA4_BUILDCOROCLOSURE(
			(libandria4_corofunc)& ??? ,
			(void*) arg /* Argument for function. */
		)
	);
	
	
	return( libandria4_main( argn, args ) );
}











/* The code below is from: https://yosefk.com/blog/coroutines-in-one-page-of-c.html */




































#include <stdio.h>
#include "coroutine.h"

typedef struct {
  coroutine* c;
  int max_x, max_y;
  int x, y;
} iter;

void iterate(void* p) {
  iter* it = (iter*)p;
  int x,y;
  for(x=0; x<it->max_x; x++) {
    for(y=0; y<it->max_y; y++) {
      it->x = x;
      it->y = y;
      yield(it->c);
    }
  }
}

#define N 1024

int main() {
  coroutine c;
  int stack[N];
  iter it = {&c, 3, 2};
  start(&c, &iterate, &it, stack+N);
  while(next(&c)) {
    printf("x=%d y=%d\n", it.x, it.y);
  }
}


