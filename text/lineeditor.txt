/*
LibAndria version 4
A C-based general purpose utility library.
Copyright (c) 2019 Jared A. Maddox

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

This grant of rights is subject to two conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

And:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#include "pascalarray.h"
#include "pascalstring.h"


	/* Success values are the updated value of curPos. */
	/* Failure values are failures. */
libandria4_uipresult pass_separator
(
	libandria4_utf32_pascalarray *str,
	libandria4_utf32_pascalarray *separators,
	
	size_t curPos,
	int stepForward
);

int libandria4_lineeditor_iteration_togglelock( libandria4_lineeditor *le,  uint8_t *epilog_toggler, uint8_t modifier );
int libandria4_lineeditor_iteration_shift( libandria4_lineeditor *le,  uint8_t *epilog_toggler, uint8_t modifier );

int libandria4_lineeditor_iteration_extent( libandria4_lineeditor *le, size_t extent );
int libandria4_lineeditor_iteration_horizontal( libandria4_lineeditor *le, int rightward, int selmod );




Components:
	Input -> Extended characters
	
	
	
	
	LineEdit
		(
			row number, column number,
			string to edit, display length (the size actually shown),
			virtual window (if smaller than display length ignored, else ALLOWED string length is this size & autoscrolls),
			seperators (the characters to treat as word separators for word-jump commands (control-arrow combos)),
			terminators (as seperators, but the things that should exit the line editor; should usually include vertical movements),
			edit masks (the pattern to FORCE the characters to, should probably be a regex),
			cursor position (the column to start the cursor in), cursor result (the cursor column when the editor exited),
			terminator (the key sequence that actually caused the editor to exit)
		)



#include "ctsengine.h"
#include "commoniokeysyms.h"


enum
{
	libandria4_lineeditor_mods_nomods = 0,
	
	libandria4_lineeditor_mods_release = 1,
	
	libandria4_lineeditor_mods_chara1 = 2, /* Standard shift. */
	libandria4_lineeditor_mods_chara2 = 4, /* Alt-graphic, probably just ignore this. */
	libandria4_lineeditor_mods_command = 8, /* Currently control, maybe configurable in the future. */
	libandria4_lineeditor_mods_select = 16,
	libandria4_lineeditor_mods_scroll = 32,
	libandria4_lineeditor_mods_insert = 64,
	
	libandria4_lineeditor_mods_last = 128
};
enum
{
	libandria4_lineeditor_oper_init = 0,
	
	libandria4_lineeditor_oper_fetch,
	libandria4_lineeditor_oper_dispatch,
	libandria4_lineeditor_oper_
};
typedef struct libandria4_lineeditor libandria4_lineeditor;
struct libandria4_lineeditor
{
	libandria4_cts_closure delegate, fetcher, commandkey, altcommandkey, ???;
	
	uintptr_t operation;
	libandria4_commoniokeys_simplekeycode key;
	
		/* The string to edit. */
	libandria4_utf32_pascalarray *str;
		/* The recognized separator characters. */
	libandria4_utf32_pascalarray *sep;
	
	uint8_t modifiers;
		/* For both: 0 is BEFORE the first character, 1 is AFTER the first character, etc. */
	size_t cursor, select;
	
	??? stream;
	
	??? ;
};
/*
The built-ins for Larry Stone's Linetastic for QBasic
              Backspace       Deletes character to left of cursor
              Delete          Deletes character under cursor
              Ctrl + Home     Deletes from cursor to beginning of line
              Ctrl + End      Deletes from cursor to end of line
              Ctrl + Right    Move to word on right (skips separaters)
              Ctrl + Left     Move to word on left (skips separaters)
              Home            Move to beginning of string
              End             Move to space after last char of string
              Right           Move cursor one character to right
*/
libandria4_cts_closure libandria4_lineeditor_iteration( libandria4_cts_closure *ctx, void *le_ )
{
	libandria4_cts_closure ret =
		LIBANDRIA4_CTS_BUILDCLOSURE( &libandria4_lineeditor_iteration, le );
	int retroute = 0;
	int resi;
	
	libandria4_lineeditor *le = (libandria4_lineeditor*)le_;
	
	if( !le || !isvalid( le ) )
	{
		??? ;
	}
	
	uint8_t mod_xor = le->modifiers & libandria4_lineeditor_mods_release;
	
	switch( le->operation )
	{
		/* Note: should do setup steps somewhere. */
		
		case libandria4_lineeditor_oper_init:
			le->operation = libandria4_lineeditor_oper_fetch;
			le->key = 0;
			le->modifiers = 0;
			
			/* Leave the return as-is. */
			
			break;
		case libandria4_lineeditor_oper_fetch:
			le->operation = libandria4_lineeditor_oper_dispatch;
			
			resi = libandria4_cts_push_ctsclsr( ctx, 0,  &ret );
			if( !resi )
			{
				??? ;
			}
			ret = le->fetcher;
			
			break;
		case libandria4_lineeditor_oper_dispatch:
			ret.func = &libandria4_lineeditor_iteration_onkey;
			break;
			case sub-case edit-mask chara :
				break;
				case sub-sub-case set chara :
					break;
			case sub-case horizontal :
				break;
				case sub-sub-case word-jumps :
					break;
			case sub-case backspace/delete :
				break;
			case sub-case selector :
				break;
				case sub-sub-case word-selector :
					break;
			case sub-case clipboard :
				/*
			int head##pascalarray_excerpt_isvalid( head##pascalarray_excerpt *exc ); \
			head##pascalarray_result head##pascalarray_excerpt_arrayify( head##pascalarray_excerpt *exc, \
				size_t padsize, (type) padval ); \
			head##pascalarray_result head##pascalarray_excerpt_inversearrayify( head##pascalarray_excerpt *exc, \
				size_t padsize, (type) padval );
				*/
				break;
			case sub-case IME :
				break;
		case line-scroll :
			break;
		case terminate :
			break;
		
		default:
			return( ??? error_continuation ??? ( "Bad step", le->operation ) );
	}
	
	return( ret );
}
libandria4_cts_closure libandria4_lineeditor_iteration_onkey( libandria4_cts_closure *ctx, void *le_ )
{
	libandria4_cts_closure ret =
		LIBANDRIA4_CTS_BUILDCLOSURE( &libandria4_lineeditor_iteration, le );
	int retroute = 0;
	int resi;
	
	libandria4_lineeditor *le = (libandria4_lineeditor*)le_;
	
	if( !le || !isvalid( le ) )
	{
		??? ;
	}
	
	if( le->operation == libandria4_lineeditor_oper_dispatch )
	{
			uint8_t mod_xor = le->modifiers & libandria4_lineeditor_mods_release;
			
			le->operation = libandria4_lineeditor_oper_fetch;
			mod_xor |= ( le->modifiers & libandria4_lineeditor_mods_release ) ?
				libandria4_lineeditor_mods_release : 0;
			switch( le->key )
			{
					/* Implicit exits */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurUp:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurDown:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PageUp:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PageDown:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerUp:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerDown:
					retroute += 1;
					/* Half-effective exits */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurUpRight:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurDownRight:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurDownLeft:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurUpLeft:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerUpRight:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerDownRight:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerDownLeft:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerUpLeft:
					retroute += 1;
					/* Explicit exits */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Escape:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Return:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Execute:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Cancel:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Break:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Quit:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Commit:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Finish:
					retroute += 1;
						/* Move the original caller into ret. */
					resi = libandria4_cts_pop_ctsclsr( ctx, 0,  &ret );
					if( !resi )
					{
						switch( retroute )
						{
							case 1:
							case 2:
							case 3:
							default:
								??? ;
						}
						
						???
					}
					break;
					
						/* Explicit selection. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_SelectLock:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ShiftLock:
					resi =
						libandria4_lineeditor_iteration_togglelock
						( le,  &mod_xor, libandria4_lineeditor_mods_select );
					if( !resi )
					{
						???
					}
					if
					(
						( le->modifiers & libandria4_lineeditor_mods_select ) &&
						( le->modifiers & libandria4_lineeditor_mods_scroll )
					)
					{
						mod_xor |= libandria4_lineeditor_mods_scroll;
					}
					break;
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ExtendSelection:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Shift:
					resi =
						libandria4_lineeditor_iteration_shift
						( le,  &mod_xor, libandria4_lineeditor_mods_select );
					if( !resi )
					{
						???
					}
					if
					(
						( le->modifiers & libandria4_lineeditor_mods_select ) &&
						( le->modifiers & libandria4_lineeditor_mods_scroll )
					)
					{
						mod_xor |= libandria4_lineeditor_mods_scroll;
					}
					break;
						/* Explicit scrolling. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ScrollLock:
					resi =
						libandria4_lineeditor_iteration_togglelock
						( le,  &mod_xor, libandria4_lineeditor_mods_scroll );
					if( !resi )
					{
						???
					}
					if
					(
						( le->modifiers & libandria4_lineeditor_mods_select ) &&
						( le->modifiers & libandria4_lineeditor_mods_scroll )
					)
					{
						mod_xor |= libandria4_lineeditor_mods_select;
					}
					break;
						/* Common modifiers */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Ctrl:
					resi =
						libandria4_lineeditor_iteration_shift
						( le,  &mod_xor, libandria4_lineeditor_mods_command );
					if( !resi )
					{
						???
					}
					break;
					
					/* Deletions */
						/* These delete selections if existent, else their named function. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Backerase: /* backspace */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Forwarderase: /* delete */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_DeleteWord:
						/* As above, but clear to end of line as non-select action. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ProgressiveDelete:
						/* As above, but clear everything as the non-select action. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Clear:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Reset:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ScreenErase:
					resi = libandria4_lineeditor_iteration_deleteselection( libandria4_lineeditor *le );
					if( resi == 0 )
					{
						switch( le->key )
						{
							/* Note that command -backerase or -forwarderase should get rid of the word. */
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Backerase: /* backspace */
								if( le->cursor > 0 )
								{
									resi =
										libandria4_utf32_stringops_mutatingdelete
										(
											le->str->body, le->str->len,
											le->cursor - 1, 1, 0x00 /* Ascii null. */
										);
									if( !resi )
									{
										??? ;
									}
									
								} else {
									
									/* Emit a beep! */
								}
								break;
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Forwarderase: /* delete */
								if( le->cursor < le->str->len )
								{
									resi =
										libandria4_utf32_stringops_mutatingdelete
										(
											le->str->body, le->str->len,
											le->cursor, 1, 0x00 /* Ascii null. */
										);
									if( !resi )
									{
										??? ;
									}
									
								} else {
									
									/* Emit a beep! */
								}
								break;
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_DeleteWord:
								{
									libandria4_uipresult resui;
									libandria4_success_uipresult a;
									libandria4_failure_uipresult b = { 0 };
									size_t start, end;
									
									resui = pass_separator( le->str, le->sep,  le->cursor, -1 );
									LIBANDRIA4_UIPRESULT_BODYMATCH( resui, LIBANDRIA4_OP_SETa, LIBANDRIA4_OP_SETb )
									if( b.val )
									{
										return( -( fail.val ) );
									}
									start = a.val;
									
									resui = pass_separator( le->str, le->sep,  start, 1 );
									LIBANDRIA4_UIPRESULT_BODYMATCH( resui, LIBANDRIA4_OP_SETa, LIBANDRIA4_OP_SETb )
									if( b.val )
									{
										return( -( fail.val ) );
									}
									end = a.val;
									
									if( start <= le->cursor && end >= le->cursor && start != end )
									{
										resi =
											libandria4_utf32_stringops_mutatingdelete
											(
												le->str->body, le->str->len,
												start, end - start, 0x00 /* Ascii null. */
											);
										if( !resi )
										{
											??? ;
										}
										
									} else {
										
										/* Emit a beep! */
									}
								}
									/* As above, but clear to end of line as non-select action. */
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ProgressiveDelete:
								if( le->cursor < le->str->len )
								{
									resi =
										libandria4_utf32_stringops_mutatingdelete
										(
											le->str->body, le->str->len,
											le->cursor, le->str->len - le->cursor, 0x00 /* Ascii null. */
										);
									if( !resi )
									{
										??? ;
									}
									
								} else {
									
									/* Emit a beep! */
								}
								break;
									/* As above, but clear everything as the non-select action. */
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Clear:
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Reset:
							case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_ScreenErase:
								if( le->cursor < le->str->len )
								{
									resi =
										libandria4_utf32_stringops_mutatingdelete
										(
											le->str->body, le->str->len,
											0, le->str->len, 0x00 /* Ascii null. */
										);
									if( !resi )
									{
										??? ;
									}
									
								} else {
									
									/* Emit a beep! */
								}
								break;
							default: /* "Impossible", so logic bug. */
								??? ;
						}
						
					} else if( resi < 0 )
					{
						???
					}
					break;
					
						/* Movement */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Begin:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Home:
					resi = libandria4_lineeditor_iteration_extent( le, 0 );
					if( !resi )
					{
						??? ;
					}
					break;
						/* End key. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_End:
					resi = libandria4_lineeditor_iteration_extent( le, ??? /* End of line. */ );
					if( !resi )
					{
						??? ;
					}
					break;
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurRight:
					resi = libandria4_lineeditor_iteration_horizontal( le, 1, 0 );
					if( !resi )
					{
						??? ;
					}
					break;
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CurLeft:
					resi = libandria4_lineeditor_iteration_horizontal( le, -1, 0 );
					if( !resi )
					{
						??? ;
					}
					break;
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerRight:
					resi = libandria4_lineeditor_iteration_horizontal( le, 1, 1 );
					if( !resi )
					{
						??? ;
					}
					break;
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_PointerLeft:
					resi = libandria4_lineeditor_iteration_horizontal( le, -1, 1 );
					if( !resi )
					{
						??? ;
					}
					break;
					
						/* Exterior actions */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Menu:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Print:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Find:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Help:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Copy:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Delegate:
					resi = libandria4_cts_push_ctsclsr( ctx, 0,  &ret );
					if( !resi )
					{
						??? ;
					}
					ret = le->delegate;
					break;
				default:
					if( !( le->key & LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODEMASK_Unicode_illegal_mask ) )
					{
						if
						(
							( le->modifiers & libandria4_lineeditor_mods_command ) &&
							1
						)
						{
							/*
								Control characters:
									z: undo
									y: redo
									n: new
									s: save
									o: open
									w: close
									a: select all
									p: print
									c: copy
									v: paste
									x: cut to clipboard
									f: find
									h: replace dialog or similar
									g: goto line
									space: autocomplete
									shift-tab: reduce leading whitespace
									r: reload
									ctrl u: to uppercase
									ctrl shift u: to lowercase
							*/
							
							???
							
						} else if( ??? )
						{
							resi =
								libandria4_utf32_stringops_mutatingdelete
								(
									le->str->body, le->str->len,
									0, le->str->len, 0x00 /* Ascii null. */
								);
							if( !resi )
							{
								??? ;
							}
							
						} else {
							
							/* Add character. */
							
							if( le->modifiers & libandria4_lineeditor_mods_insert )
							{
								resi =
									libandria4_utf32_stringops_mutatinginsert
									(
										le->str->body, le->str->len,
										le->cursor, le->key, 0 /* Ascii null. */, int force
									);
								
							} else {
								
								resi =
									libandria4_utf32_stringops_mutatingoverwrite
									(
										le->str->body, le->str->len,
										le->cursor, le->key, 0, 0
									);
							}
							if( !resi )
							{
								??? ;
							}
						}
						
						
						??? ; \
						
						break;
					}
					/* Fall through. */
						/* Unused modifiers */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_InsertLock:
					??? /* Insert is needed! */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_MouseKeysLock:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_DragLock:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_CapsLock:
					/* Note: Meta == the Win and Mac-command key per Mozilla. */
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Meta:
				case LIBANDRIA4_COMMONIOKEYS_SIMPLEKEYCODE_Alt:
					break;
			}
			le->modifiers ^= mod_xor;
			
	} else {
		
			/* Error!Bad operation setting! */
		??? ;
	}
	
	return( ret );
}
libandria4_cts_closure libandria4_lineeditor_iteration_command( libandria4_cts_closure *ctx, void *le_ )
{
	libandria4_cts_closure ret =
		LIBANDRIA4_CTS_BUILDCLOSURE( &libandria4_lineeditor_iteration, le );
	int retroute = 0;
	int resi;
	
	libandria4_lineeditor *le = (libandria4_lineeditor*)le_;
	
	if( !le || !isvalid( le ) )
	{
		??? ;
	}
	
	switch( le->key )
	{
		case ??? :
		
		default:
			??? ;
	}
	
	return( ret );
}











#include "commonlib.h"

	/* stepForward is STEREOTYPICALLY positive when a user presses */
	/*  control-right, and stereotypically not positive when the user */
	/*  presses control-left. */
libandria4_uipresult pass_separator
(
	libandria4_utf32_pascalarray *str,
	libandria4_utf32_pascalarray *separators,
	
	size_t curPos,
	int stepForward
)
{
	stepForward = ( stepForward ? 1 : -1 );
	intmax_t bounds = ( !stepForward ? -1 : A->len );
	size_t curOff = 0;
	uintptr_t sepOff = 0, found;
	
		/* Search for a separator. */
	while( curPos + curOff != bounds )
	{
		void *a;
		libandria4_failure_uipresult e = { 0 };
		
		libandria4_ptrresult res =
			libandria4_memmem
			(
				(void*)( separators->body ), separators->len,
					/* We only check the CURRENT string character, not all of them. */
				(void*)&( str->body[ curPos + curOff ] ), sizeof( char ), sizeof( char )
			);
		LIBANDRIA4_PTRRESULT_BODYMATCH( res, LIBANDRIA4_OP_SETa, LIBANDRIA4_OP_SETe );
		if( e.val == LIBANDRIA4_RESULT_FAILURE_DOMAIN )
		{
			/* The last argument wasn't an integer multiple of the */
			/*  next-to-last, which obviously shouldn't be possible, */
			/*  so logic fault. */
			LIBANDRIA4_UIPRESULT_RETURNFAILURE(
				LIBANDRIA4_RESULT_FAILURE_LOGICFAULT );
		}
		sepOff = (uintptr_t)a;
		
		if( sepOff )
		{
			found = sepOff;
			curPos += curOff;
			curOff = 0;
			
				/* Exit the while loop. */
			break;
		}
		
		curOff += stepForward;
	}
	if( !sepOff )
	{
			/* No match, lets return. */
		LIBANDRIA4_UIPRESULT_RETURNFAILURE(
			LIBANDRIA4_RESULT_FAILURE_EOF );
	}
	
		/* Move past all adjacent duplicate separators. */
	while( sepOff )
	{
		curOff += stepForward;
		if( !( curPos + curOff ) || curPos + curOff >= bounds )
		{
			break;
		}
		
			/* Note: 1 indexed. */
		sepOff = ( ( separators->body[ found ] == str->body[ curPos + curOff ] ) ? 1 : 0 );
		if( !sepOff )
		{
			/* Should curPos be something else here? */
			curOff = 0;
		}
	}
	curPos += curOff;
	
	LIBANDRIA4_UIPRESULT_RETURNSUCCESS( curPos );
}

int libandria4_lineeditor_iteration_togglelock( libandria4_lineeditor *le,  uint8_t *epilog_toggler, uint8_t modifier )
{
	if( le && epilog_toggler )
	{
		if( !modifier )
		{
			return( 0 );
		}
		
		if( !( le->modifiers & libandria4_lineeditor_mods_release ) )
		{
			le->modifiers ^= modifier;
			if( ( *epilog_toggler ) & modifier )
			{
				( *epilog_toggler ) ^= modifier;
			}
		}
		/* We just ignore the release case. */
		
		return( 1 );
	}
	
	return( -1 );
}
int libandria4_lineeditor_iteration_shift( libandria4_lineeditor *le,  uint8_t *epilog_toggler, uint8_t modifier )
{
	if( le && epilog_toggler )
	{
		if( !modifier )
		{
			return( 0 );
		}
		
		if( !( le->modifiers & libandria4_lineeditor_mods_release ) )
		{
			le->modifiers |= modifier;
			if( ( *epilog_toggler ) & modifier )
			{
				( *epilog_toggler ) ^= modifier;
			}
			
		} else {
			
			le->modifiers &= ~( modifier );
			if( ( *epilog_toggler ) & modifier )
			{
				( *epilog_toggler ) ^= modifier;
			}
		}
		
		return( 1 );
	}
	
	return( -1 );
}

				/*
			int head##pascalarray_excerpt_isvalid( head##pascalarray_excerpt *exc ); \
			head##pascalarray_result head##pascalarray_excerpt_arrayify( head##pascalarray_excerpt *exc, \
				size_t padsize, (type) padval ); \
			head##pascalarray_result head##pascalarray_excerpt_inversearrayify( head##pascalarray_excerpt *exc, \
				size_t padsize, (type) padval );
				*/

int libandria4_lineeditor_iteration_deleteselection( libandria4_lineeditor *le )
{
	if( le )
	{
		if( le->cursor == le->select )
		{
			return( 0 );
		}
		
		int endwards = ( le->cursor < le->select ) ? 1 : 0;
		size_t start = ( endwards ? le->cursor : le->select );
		size_t len = ( endwards ? le->select : le->cursor ) - start;
		libandria4_utf32_pascalarray_except exc =
			LIBANDRIA4_DEFINE_PASCALARRAY_EXCERPT_LITERAL(
				libandria4_utf32_pascalarray,  le->str, start, len );
		if( !( libandria4_utf32_pascalarray_excerpt_isvalid( &exc ) ) )
		{
			return( -2 );
		}
		
			/* Delete the designated range. */
		int resi =
			libandria4_utf32_stringops_mutatingdelete
			(
				le->str->body, le->str->len,
				start, len, 0x00 /* Ascii null. */
			);
		if( !resi )
		{
			return( -3 );
		}
		
		le->select = le->cursor;
		
		return( 1 );
	}
	
	return( -1 );
}
int libandria4_lineeditor_iteration_extent( libandria4_lineeditor *le, size_t extent )
{
	if( le )
	{
		if( le->modifiers & libandria4_lineeditor_mods_command )
		{
			int endwards = ( le->cursor < extent ) ? 1 : 0;
			size_t start = ( endwards ? 0 : le->cursor );
			size_t len = ( endwards ? le->cursor : le->str->len ) - start;
			libandria4_utf32_pascalarray_except exc =
				LIBANDRIA4_DEFINE_PASCALARRAY_EXCERPT_LITERAL(
					libandria4_utf32_pascalarray,  le->str, start, len );
			if( !( libandria4_utf32_pascalarray_excerpt_isvalid( &exc ) ) )
			{
				return( -2 );
			}
			
				/* Delete the designated range. */
			int resi =
				libandria4_utf32_stringops_mutatingdelete
				(
					le->str->body, le->str->len,
					start, len, 0x00 /* Ascii null. */
				);
			if( !resi )
			{
				return( -3 );
			}
			
			le->select = le->cursor;
			
		} else if( le->modifiers & libandria4_lineeditor_mods_select )
		{
			le->select = extent;
			
		} else {
			
			le->cursor = extent;
			le->select = le->cursor;
		}
		
		return( 1 );
	}
	
	return( -1 );
}
int libandria4_lineeditor_iteration_horizontal( libandria4_lineeditor *le, int rightward, int selmod )
{
	rightward = ( rightward ? 1 : -1 );
	selmod = ( selmod ? 1 : 0 );
	int usesel = ( ( !( le->modifiers & libandria4_lineeditor_mods_select ) == selmod ) ? 1 : 0 );
	if( le )
	{
		if( le->modifiers & libandria4_lineeditor_mods_command )
		{
			/* Move by a word. Note that select still affects what EXACTLY happens. */
			libandria4_uipresult res =
				pass_separator( le->str, le->sep,  ( usesel ? le->select : le->cursor ), rightward );
			libandria4_success_uipresult step;
			libandria4_failure_uipresult fail = { 0 };
			LIBANDRIA4_UIPRESULT_BODYMATCH( var, matcha, matchb )
			if( fail.val )
			{
				return( -( fail.val ) );
			}
			
			if( usesel )
			{
				le->select += step.val * rightward;
				
			} else {
				le->cursor += step.val * rightward;
				le->select = le->cursor;
			}
			
		} else if( usesel )
		{
			le->select += 1 * rightward;
			
		} else {
			
			le->cursor += 1 * rightward;
			le->select = le->cursor;
		}
		
		return( 1 );
	}
	
	return( -1 );
}
