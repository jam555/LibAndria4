/*
LibAndria version 4
A C-based general purpose utility library.
Copyright (c) 2024 Jared A. Maddox

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

This grant of rights is subject to two conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

And:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



Red-black trees:
	Based on Eternally Confuzzled / Julienne Walker's code, search on the Wayback Machine around Feburary of 2018.
	The red+black height can be unpredictable, but the black height is always the same between root and all leaves...
		EXCEPT during insertion and deletion, when it will ONLY be off by 1 in either direction, and during which we
		can ALWAYS know WHERE the imbalance is.
	Red violations:
		Insertion:
		Deletion:
	Added black:
		Carry positive black down the tree until it can be "legally" turned into a red.
	Deleted black:
		Carry negative black down the tree until a red can be "legally" turned into a black.
	Non-black root:
		Color root black.
	;
	
	
	
	
	
	
		LIBANDRIA4_MONAD_EITHER_BUILDTYPE( name ## _eitherrnodptr, unsigned, (name)* );
			
			( name ## _eitherrnodptr ) ( name ## _eitherrnodptr_err )( unsigned err )
				{ return( LIBANDRIA4_MONAD_EITHER_BUILDLEFT( name ## _eitherrnodptr, unsigned, err ) ); }
			
			( name ## _eitherrnodptr ) ( name ## _eitherrnodptr_nodeptr )( (name) *ptr )
				{ return( LIBANDRIA4_MONAD_EITHER_BUILDRIGHT( name ## _eitherrnodptr, (name)*, ptr ) ); }
	
	
	
	/* See if the code below already has equivalents. */
	
	typedef struct libandria4_doubleint
	{
		int left, right;
		
	} libandria4_doubleint;
	libandria4_doubleint libandria4_doubleint_build( int l, int r )
	{
		return( (libandria4_doubleint){ l, r } );
	}
	#define LIBANDRIA4_RBTREES_REDCHILDREN( name,  macroset ) \
		libandria4_doubleint ( name ## _redchildren )( (name) *parent ) { \
			if( !parent ) { return( libandria4_doubleint_build( -1, -1 ) ); } \
			\
			( name ## _bitup ) res; \
			(name) *left = 0, *right = 0, *a; \
			libandria4_commonio_err e = 0, d = 0; \
			\
			res = macroset ## _GETLEFT( parent ); \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					LIBANDRIA4_OP_SETd ); \
				if( e ) { return( libandria4_doubleint_build( -e, -1 ) ); } \
				if( d ) { return( libandria4_doubleint_build( -2, -1 ) ); } \
				left = a; \
			\
			res = macroset ## _GETRIGHT( parent ); \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					LIBANDRIA4_OP_SETd ); \
				if( e ) { return( libandria4_doubleint_build( -1, -e ) ); } \
				if( d ) { return( libandria4_doubleint_build( -1, -2 ) ); } \
				right = a; \
			\
			return( \
				libandria4_doubleint_build( \
					LIBANDRIA4_RBTREES_ISRED( left ), LIBANDRIA4_RBTREES_ISRED( right ) ) ); }
	
	
	
	/* The code below is in various ways wrong. It accesses colors directly, doesn't have error code filled, etc. Fix before using. */
	
	#define LIBANDRIA4_RBTREES_ISRED( macroset,  nodeptr ) ( ( !!(nodeptr) ) ? ( (nodeptr)->is_red ? 1 : 0 ) : 0 )
	#define LIBANDRIA4_RBTREES_SETRED( macroset,  nodeptr ) ( ( !!(nodeptr) ) ? ( (nodeptr)->is_red = 1, 1 ) : 0 )
	#define LIBANDRIA4_RBTREES_SETBLACK( macroset,  nodeptr ) ( ( !!(nodeptr) ) ? ( (nodeptr)->is_red = 0, 1 ) : 0 )
		/* Note that this should return a double-pointer, not a normal single-pointer. */
		/* Styled after eternally-confuzzled's (Julienne Walker's) approach. */
	#define LIBANDRIA4_RBTREES_FETCHCHILD( macroset,  nodeptr, key, on_badrange, on_null ) \
		( ( !!(nodeptr) ) ? \
			( (key) == 0 ? \
				&( macroset ## GETLEFT( nodeptr ) ) : \
				( (key) > 0 ? &( macroset ## GETRIGHT( nodeptr ) ) : (on_badrange( (nodeptr), (key) )) ) ) : \
			(on_null( (nodeptr) )) )
		/* dir==0 raises the left size, dir==1 raises the right side. */
	#define LIBANDRIA4_RBTREES_SINGLEROT( name,  basedblptr, dir, on_negdir, on_null, on_succ ) { \
			if( (dir) < 0 ) { ( on_negdir( (basedblptr), (dir) ) ); } \
			if( !( !(basedblptr) || !*(basedblptr) ) ) { ( on_null( (basedblptr), (dir) ) ); } \
			\
				/* Left is lower-keyed, right is higher-keyed, a rotation makes it's namesake taller. */ \
			( name ## _bitup ) res; \
			if( (dir) == 0 ) { /* Left */ \
				res = name ## _rotateleft( *(basedblptr) ); } \
			else { /* Right */ \
				res = name ## _rotateright( *(basedblptr) ); } \
			(name) *old = *(basedblptr), *a = 0; \
			libandria4_commonio_err e = 0; \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					??? ); \
				if( e ) { ??? } \
				*(basedblptr) = a; \
			\
			LIBANDRIA4_RBTREES_SETRED( macroset,  old ); \
			LIBANDRIA4_RBTREES_SETBLACK( macroset,  *(basedblptr) ); \
			\
			( on_succ( (basedblptr), (dir) ) ); }
	#define LIBANDRIA4_RBTREES_DOUBLEROT( name,  macroset,  basedblptr, dir, on_negdir, on_null, on_succ )
		{
			if( (dir) < 0 )
			{
				( on_negdir( (basedblptr), (dir) ) );
			}
			if( !( !(basedblptr) || !*(basedblptr) ) )
			{
				( on_null( (basedblptr), (dir) ) );
			}
			
				/* Left is lower-keyed, right is higher-keyed, a rotation makes it's namesake taller. */
			(name) *old = *(basedblptr), *a = 0, *mid;
			( name ## _bitup ) res;
			libandria4_commonio_err e = 0;
			if( (dir) == 0 )
			{
				/* Left */
				
				res = macroset ## _GETRIGHT( base );
				LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
					res, \
						LIBANDRIA4_OP_SETe, \
						LIBANDRIA4_OP_SETa, \
						??? );
					if( e )
					{
						???
					}
					mid = a;
				
				res = name ## _doublerotateleft( *(basedblptr) );
				
			} else {
				
				/* Right */
				
				res = macroset ## _GETLEFT( base );
				LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
					res, \
						LIBANDRIA4_OP_SETe, \
						LIBANDRIA4_OP_SETa, \
						??? );
					if( e )
					{
						???
					}
					mid = a;
				
				res = name ## _doublerotateright( *(basedblptr) );
			}
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					??? );
				if( e )
				{
					???
				}
				*(basedblptr) = a;
			
			LIBANDRIA4_RBTREES_SETRED( macroset,  mid ); \
			LIBANDRIA4_RBTREES_SETRED( macroset,  old ); \
				/* The node that was furthest from *basedblptr is now IN basedblptr, */
				/*  and DIRECTLY the parent of both old & mid. Thus, setting those */
				/*  two to red DOES NOT produce a red violation, despite my initial */
				/*  concerns. */
			LIBANDRIA4_RBTREES_SETBLACK( macroset,  *(basedblptr) ); \
			
			( on_succ( (basedblptr), (dir) ) );
		}
	#define LIBANDRIA4_RBTREES_BUILDBALANCE( name,  macroset ) \
		( name ## _eitherrnodptr ) ( name ## _insertrebalance )( (name) *base, int dir ) { \
			if( !base || ( dir != -1 && dir != 1 ) ) { \
				return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_DOMAIN ) ); } \
			\
			libandria4_commonio_err e = 0, d = 0; \
			(name) *a; ( name ## _bitup ) res; \
			libandria4_doubleint gcol; int ared, ired; \
			\
			/* Pathing. */ gcol = ( name ## _redchildren )( base ); \
			if( dir == -1 ) { \
				ared = gcol.left; ired = gcol.right; \
				res = macroset ## _GETLEFT( base ); \
				LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
					res, \
						LIBANDRIA4_OP_SETe, \
						LIBANDRIA4_OP_SETa, \
						LIBANDRIA4_OP_SETd ); \
					if( e ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_RANGE ) ); } \
					if( d ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_BROKEN ) ); } } \
			else { \
				ared = gcol.right; ired = gcol.left; \
				res = macroset ## _GETRIGHT( base ); \
				LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
					res, \
						LIBANDRIA4_OP_SETe, \
						LIBANDRIA4_OP_SETa, \
						LIBANDRIA4_OP_SETd ); \
					if( e ) { \
						return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_RANGE ) ); } \
					if( d ) { \
						return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_BROKEN ) ); } } \
			\
			gcol = ( name ## _redchildren )( a ); \
			if( ared && ired ) { /* Red-red case 1: both children red, any grandchild red. */ \
				if( gcol.left || gcol.right ) { \
					LIBANDRIA4_RBTREES_SETRED( macroset,  base ); \
					LIBANDRIA4_RBTREES_SETBLACK( macroset,  left ); \
					LIBANDRIA4_RBTREES_SETBLACK( macroset,  right ); } } \
			else if( ared && !ired ) { /* Red-red case 2 & 3: active child & grandchild red, inactive child black. */ \
				if( dir == -1 ? gcol.left : gcol.right ) { /* Red-red case 2: OUTER grandchild red. */ \
					LIBANDRIA4_RBTREES_SINGLEROT( name,  &base, ( dir ? 0 : 1 ), ??? on_negdir, on_null, on_succ ); } \
				else if( dir != -1 ? gcol.left : gcol.right ) { /* Red-red case 3: INNER grandchild red. */ \
					LIBANDRIA4_RBTREES_DOUBLEROT( name,  macroset,  &base, ( dir ? 0 : 1 ), on_negdir, on_null, on_succ ); } } \
			\
			return( return( ( name ## _eitherrnodptr_nodeptr )( base ) ); ); }
	#define LIBANDRIA4_RBTREES_BUILDINNERINSERT( name,  macroset ) \
			/* addition must be set to red ahead of time! Not optional! Also, it's key MUST be set. */ \
		( name ## _eitherrnodptr ) ( name ## _innerinsert )( (name) *base,  (name) *addition ) { \
			if( !addition ) { \
				return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_DOMAIN ) ); } \
			if( !ret ) { return( ( name ## _eitherrnodptr_nodeptr )( addition ) ); } \
			\
				/* -1 if ret>addition, 0 if ret==addition, else 1. */ \
			int test = macroset ## _COMPAREn( base, addition ); (name) *tmp = 0; ( name ## _bitup ) res; \
			switch( test ) { \
				case -1: /* ( base>addition ) == ( addition<base ), so left case. */ \
					res = macroset ## _GETLEFT( base ); break; \
				case 1: /* Right case. */ res = macroset ## _GETRIGHT( base ); break; \
				case 0: return( ( name ## _eitherrnodptr_nodeptr )( base ) ); \
				default: return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_UNDIFFERENTIATED ) ); } \
			libandria4_commonio_err e = 0, d = 0; \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETtmp, \
					LIBANDRIA4_OP_SETd ); \
				if( e ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_RANGE ) ); } \
				if( d ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_BROKEN ) ); } \
			\
			( name ## _eitherrnodptr ) res = ( name ## _innerinsert )( tmp,  addition ); \
				LIBANDRIA4_MONAD_EITHER_BODYMATCH( res, LIBANDRIA4_OP_SETe, LIBANDRIA4_OP_SETtmp ); \
				if( e ) { return( ( name ## _eitherrnodptr_err )( e ) ); } \
			\
			switch( test ) { \
				case -1: res = macroset ## _SETLEFT( base, tmp ); break; \
				case 1: res = macroset ## _SETRIGHT( base, tmp ); break; \
				default: /* Should never be reached. */ \
					return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_LOGICFAULT ) ); } \
				/* Warning! As of this point, the 'ret' var itself should be absolutely unmodified! */\
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_NULL_MACRO, \
					LIBANDRIA4_OP_SETd ); \
				if( e ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_RANGE ) ); } \
				if( d ) { return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_BROKEN ) ); } \
			\
			return( ( name ## _insertrebalance )( base, test ) ); }
	#define LIBANDRIA4_RBTREES_BUILDINSERT( name,  macroset ) \
			/* Will itself set addition to red. */ \
		( name ## _eitherrnodptr ) ( name ## _insert )( (name) **base,  (name) *addition ) { \
			if( !base || !addition ) { \
				return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_DOMAIN ) ); } \
			\
			LIBANDRIA4_RBTREES_SETRED( macroset,  addition ); \
			\
			(name) *tmp = 0; libandria4_commonio_err e = 0; \
			( name ## _eitherrnodptr ) res = ( name ## _innerinsert )( *base,  addition ); \
				LIBANDRIA4_MONAD_EITHER_BODYMATCH( res, LIBANDRIA4_OP_SETe, LIBANDRIA4_OP_SETtmp ); \
				if( e ) { return( ( name ## _eitherrnodptr_err )( e ) ); } \
				*base = tmp; \
			LIBANDRIA4_RBTREES_SETBLACK( macroset,  *base ); \
			\
			return( ( name ## _eitherrnodptr_nodeptr )( *base ) ); }
		/* This code will test/verify the entire tree. Returns the black height on success, else returns a negative. */
	#define LIBANDRIA4_RBTREES_ASSERT( name,  macroset ) \
		int ( name ## _rbassert )( (name) *base ) { \
			if( !base ) { /* Null ptr */ ; } \
			\
			(name) *left, *right, *a = 0; \
			( name ## _bitup ) res; \
			libandria4_commonio_err e = 0; \
			/* Fetch branches. */
			res = macroset ## _GETLEFT( base ); \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					??? ); \
				if( e ) { ??? } \
				left = a; \
			res = macroset ## _GETRIGHT( base ); \
			LIBANDRIA4_MONAD_BITUPLIC_BODYMATCH( \
				res, \
					LIBANDRIA4_OP_SETe, \
					LIBANDRIA4_OP_SETa, \
					??? ); \
				if( e ) { ??? } \
				right = a; \
			/* Check red violations. */ \
			int isred = LIBANDRIA4_RBTREES_ISRED( base ); \
			if( isred ) { \
				if( LIBANDRIA4_RBTREES_ISRED( left ) || LIBANDRIA4_RBTREES_ISRED( right ) ) { \
					return( red violation ); } } \
			/* Check sort order. */ \
			if ( \
				( left && BADORDER( left, base ) ) || \
				( right && BADORDER( base, right ) ) ) { \
				return( sort violation ); } \
			/* Check balance. */ \
			int left_a = ( name ## _rbassert )( left ); \
			int right_a = ( name ## _rbassert )( left ); \
			if( left_a != 0 && right_a != 0 && left_a != right_a ) { \
				return( height mismatch ); } \
			/* Count black (and only black) nodes. */ \
			if( left_a != 0 && right_a != 0 ) { \
				return( LIBANDRIA4_RBTREES_ISRED( base ) ? left_a : left_a + 1 ); } \
			\
			else { return( 0 ); } }
	
	
	
	
	
	
	
	
	;
	( name ## _eitherrnodptr ) ( name ## _delete )( (name) **base,  (keytype) *targkey )
	{
		if( !base || !targkey ) {
			return( ( name ## _eitherrnodptr_err )( LIBANDRIA4_RESULT_FAILURE_DOMAIN ) ); }
		
		(name) *tmp = 0;
		libandria4_commonio_err e = 0;
		( name ## _eitherrnodptr ) res = ( name ## _innerdelete )( *base,  targkey );
			LIBANDRIA4_MONAD_EITHER_BODYMATCH( res, LIBANDRIA4_OP_SETe, LIBANDRIA4_OP_SETtmp );
			if( e ) { return( ( name ## _eitherrnodptr_err )( e ) ); }
			*base = tmp;
		LIBANDRIA4_RBTREES_SETBLACK( macroset,  *base );
		
		return( ( name ## _eitherrnodptr_nodeptr )( *base ) );
	}
	
	/* Try to move more to e.g. double-pointers or something similar. */
		/* This is effectively &( ->host->link[ ->dir ] )... or something along those lines. */
	typedef struct ( name ## _treeptr )
	{
		(name) *host;
		int dir;
		
	} ( name ## _treeptr ) ;
	#define PTRVAL( ref ) (ref).host->link[ (ref).dir ]
	#define BUILDPTR( hostptr, dir ) ( name ## _treeptr ){ (hostptr), (dir) }
	( name ## _eitherrnodptr ) ( name ## _innerdelete )( (name) **base,  (keytype) *targkey )
	{
		(name) prehead = { 0 }, head = { 0 }, *tmp = 0, *ret = 0;
		prehead.link[ 1 ] = &head;
		
			/* These two in the original would be name* type. */
		( name ## _treeptr ) focus, parent, grand;
		( name ## _treeptr ) found = BUILDPTR( 0, 0 );
		
		int dir = 1, dir2, dir3;
		
		/* Setup helpers. */
		grand = parent = found;
		focus = BUILDPTR( &prehead, 1 ); /* focus = &head; */
		head.link[ dir ] = *base;
		
			/* Search for, and push down, a red color. */
		while( focus.host && focus.host && PTRVAL( focus ) && PTRVAL( focus )->link[ dir ] )
		{
			int last = dir;
			
			/* Update helpers. */
			grand = parent;
			parent = focus;
			focus = BUILDPTR( PTRVAL( focus ), dir );
			dir = PTRVAL( focus )->key < *targkey;
			
			/* Save found node. */
			if( PTRVAL( focus )->key == *targkey )
			{
				found = focus;
			}
			
			/* Push the red node down. */
			if
			(
				!LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( focus ) ) &&
				LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( focus )->link[ dir ] )
			)
			{
				if( LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( focus )->link[ !dir ] ) )
				{
					tmp = PTRVAL( focus );
						LIBANDRIA4_RBTREES_SINGLEROT( name,  &tmp, dir, ??? on_negdir, on_null, on_succ );
						PTRVAL( parent )->link[ last ] = tmp;
					parent.host = PTRVAL( parent )->link[ last ];
					parent.dir = last;
				}
				else if( !LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( focus )->link[ !dir ] ) )
				{
					( name ## _treeptr ) sibling = BUILDPTR( PTRVAL( parent ), !last );
					
					if( PTRVAL( sibling ) )
					{
						if
						(
							!LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( sibling )->link[ !last ] ) &&
							!LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( sibling )->link[ last ] )
						)
						{
							/* Color flip. */
							LIBANDRIA4_RBTREES_SETBLACK( macroset,  PTRVAL( parent ) );
							LIBANDRIA4_RBTREES_SETRED( macroset,  PTRVAL( sibling ) );
							LIBANDRIA4_RBTREES_SETRED( macroset,  PTRVAL( focus ) );
							
						} else {
							
							dir2 = ( PTRVAL( grand )->link[ 1 ] == PTRVAL( parent ) );
							
							tmp = PTRVAL( parent );
							if( LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( sibling )->link[ last ] ) )
							{
								LIBANDRIA4_RBTREES_DOUBLEROT( name,  macroset,  &tmp, last, ??? on_negdir, on_null, on_succ );
								PTRVAL( grand )->link[ dir2 ] = tmp;
								
							} else if( LIBANDRIA4_RBTREES_ISRED( macroset,  PTRVAL( sibling )->link[ !last ] ) )
							{
								LIBANDRIA4_RBTREES_SINGLEROT( name,  &tmp, last, ??? on_negdir, on_null, on_succ );
								PTRVAL( grand )->link[ dir2 ] = tmp;
							}
							
							/* Ensure correct coloring. */
							LIBANDRIA4_RBTREES_SETRED( macroset,  PTRVAL( focus ) );
							LIBANDRIA4_RBTREES_SETRED( macroset,  PTRVAL( grand )->link[ dir2 ] );
							LIBANDRIA4_RBTREES_SETBLACK( macroset,  PTRVAL( grand )->link[ dir2 ]->link[ 0 ] );
							LIBANDRIA4_RBTREES_SETBLACK( macroset,  PTRVAL( grand )->link[ dir2 ]->link[ 1 ] );
						}
					}
				}
			}
		}
		
		if( found.host && PTRVAL( found ) )
		{
			/* Unlike the EternallyConfuzzled version, we really ARE swapping the nodes. */
			ret = PTRVAL( found );
			(name) *t2 = ret->link[ 0 ], *t3 = ret->link[ 1 ];
			
			/* Calculate directions. */
			dir2 = !( PTRVAL( focus )->link[ 0 ] );
			
			/* Relink, the found node will have been replaced by the leaf-ish node, and */
			/*  the leaf-ish node will have been replaced by it's (possible) solitary child. */
			tmp = PTRVAL( focus );
			PTRVAL( found ) = tmp;
			PTRVAL( focus ) = PTRVAL( focus )->link[ dir2 ];
			tmp->link[ 0 ] = t2;
			tmp->link[ 1 ] = t3;
			
			/* Recolor, since we swapped node locations instead of just data. */
			if( LIBANDRIA4_RBTREES_ISRED( macroset,  ret ) )
			{
				LIBANDRIA4_RBTREES_SETRED( macroset,  tmp );
				
			} else {
				
				LIBANDRIA4_RBTREES_SETBLACK( macroset,  tmp );
			}
			
			/* Instead of free()ing like Eternally Confuzzled, we'll be returning the node for external disposal. */
		}
		
		/* Update root & color black. */
		*base = head.link[ 1 ];
		if( *base )
		{
			LIBANDRIA4_RBTREES_SETBLACK( macroset,  *base );
		}
		
			/* Note: *ret has been removed from the tree hierarchy, so it MUST be somehow returned. */
		return( ret );
	}
	/* jsw_single(focus, dir): the dir side (0==left,1==right) becomes taller */
	/* jsw_double(parent, last): same dir/height rule as single() */
	;
	
	
	
	
	
	
	
	;





Also add: Google varints
	A variable-length number encoding. If the high bit in a byte is set, then the next byte is ALSO part of the number, else it isn't.