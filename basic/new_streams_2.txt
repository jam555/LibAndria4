/*
LibAndria version 4
A C-based general purpose utility library.
Copyright (c) 2024 Jared A. Maddox

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

This grant of rights is subject to two conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

And:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#include <stdio.h>

#include "???/monads.h"



/* Note: rewrite things a bit so that the aux data in the refcounter type */
/*  is specifically a virtual table that implements various I/O functions, */
/*  including deletion. Also, the bi-tuplic monad should be used to allow */
/*  various operations to swap refcounter pointers in and out for e.g. */
/*  composite streams, iterators over text ropes, etc. */
/* TODO: */
	/* Complete libandria4_FILE_tracker_redirect() */
	/* LIBANDRIA4_NEWSTREAMS_ONDIE() has a note about an error: fix it. */
	/* This .txt file needs to be seperated into both a .h and a .c file. */
	/* There are some notes about needed header files: fulfill them. */
	/* libandria4_FILE_tracker_close() should have it's returns rewritten. */
	/* Need to add some null-pointer checks. */
	
	typedef struct libandria4_FILE_substream_vtable libandria4_FILE_substream_vtable;
	
	
		/* libandria4_FILE_handle{} probably never had any users, */
		/*  but just in case there were, it's now named */
		/*  libandria4_FILE_tracker{}. */
	LIBANDRIA4_MONAD_REFPOINTER_DEFINE_WRAPPEDDECL(
			libandria4_FILE_tracker,
				libandria4_FILE_substream_vtable*
		);
		/* libandria4_FILE_substream used to be named libandria4_FILE_file. */
	typedef libandria4_FILE_tracker_counttype libandria4_FILE_substream;
	
	#define LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYINIT( var, innerval, aux,  failinit, badalloc, badata ) \
		LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYINIT( \
			libandria4_FILE_tracker, \
				var, innerval, aux, \
				failinit, badalloc, badata )
	#define LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYSET( var, valptr,  failneglect, failattend, succneglect, succattend, ondead ) \
		LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYSET( \
			libandria4_FILE_tracker, \
				var, valptr, \
				failneglect, failattend, succneglect, succattend, ondead )
	#define LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYDEINIT( var,  failneglect, succneglect, ondead ) \
		LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYDEINIT( \
			libandria4_FILE_tracker, \
				var, \
				failneglect, succneglect, ondead )
	
		/* If "just", replace your previous substream with this provided */
		/*  one. If "nothing", continue using your current substream. */
	LIBANDRIA4_MONAD_MAYBE_BUILDTYPE(
		libandria4_FILE_redirection,
			libandria4_FILE_substream*
	);
	#define LIBANDRIA4_FILE_REDIRECTION_TOTARGET( val ) \
		LIBANDRIA4_MONAD_MAYBE_BUILDJUST( libandria4_FILE_redirection, libandria4_FILE_substream*, val )
	#define LIBANDRIA4_FILE_REDIRECTION_TOCURRENT( ... ) \
		LIBANDRIA4_MONAD_MAYBE_BUILDNOTHING( libandria4_FILE_redirection, libandria4_FILE_substream* )
	#define LIBANDRIA4_FILE_REDIRECTION_RETURNTARGET( val ) \
		LIBANDRIA4_MONAD_MAYBE_RETURNLEFT( libandria4_FILE_redirection, libandria4_FILE_substream*, val )
	#define LIBANDRIA4_FILE_REDIRECTION_RETURNCURRENT( ... ) \
		LIBANDRIA4_MONAD_MAYBE_RETURNRIGHT( libandria4_FILE_redirection, libandria4_FILE_substream* )
	
	/* LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE() is */
	/*  libandria4_FILE_redirection{}'s equivalent of *_BODYMATCH(). */
	/*  It specifically updates a libandria4_FILE_tracker{} instance */
	/*  if AND ONLY IF a non-nothing libandria4_FILE_redirection{} */
	/*  instance is provided to it, otherwise leaving the */
	/*  libandria4_FILE_tracker{} untouched. It exists to make */
	/*  certain that libandria4_FILE_tracker{} and */
	/*  libandria4_FILE_redirection{} interact correctly. */
			#define LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_INNERTOOL( val ) \
				( LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_trip = 1, \
					LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_trig = (val) )
		/* FILE_tracker is a libandria4_FILE_tracker{} variable. */
		/* redir_var is a libandria4_FILE_redirection{} variable. */
		/* on_failattend() and: */
		/* on_failneglect() are just for logging, neither gets an */
		/*  argument. */
		/* on_redir() is for... whatever you feel like, it receives */
		/*  FILE_tracker by value as it's argument. */
	#define LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE( FILE_tracker, redir_var,  on_failattend, on_failneglect, on_redir ) \
		{ \
			libandria4_FILE_substream *LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_trig = \
				(libandria4_FILE_substream*)0; \
			int LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_trip = 0; \
			LIBANDRIA4_MONAD_MAYBE_BODYMATCH( \
				redir_var, \
				LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_INNERTOOL, \
				LIBANDRIA4_NULL_MACRO ); \
			if( LIBANDRIA4_FILE_REDIRECTION_BODYUPDATE_trip ) { \
					LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYSET( \
						FILE_tracker, redir_var, \
						on_failneglect, on_failattend, \
						LIBANDRIA4_NULL_MACRO, LIBANDRIA4_NULL_MACRO, \
						LIBANDRIA4_NULL_MACRO /* on_dead( ptr ), just for logging. */ ); \
					on_redir( FILE_tracker ); } }
	
	
	
	/* Start a separate type definitions file for the below. */
	
	
	
		/* EOF is 0, because EOF isn't really an error, and ( error * 0 ) */
		/*  should "obviously" be no error at all. */
	typedef uintptr_t libandria4_newstreams_err;
	static const libandria4_newstreams_err libandria4_newstreams_eof =
		(libandria4_newstreams_err)0;
	#define LIBANDRIA4_NEWSTREAMS_EOF ( libandria4_newstreams_eof )
	
	LIBANDRIA4_MONAD_EITHER_BUILDTYPE(
		libandria4_newstreams_result1,
			size_t,
			libandria4_newstreams_err
	);
	#define LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDSIZET( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDLEFT( libandria4_newstreams_result1, size_t, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDRIGHT( libandria4_newstreams_result1, libandria4_newstreams_err, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT1_RETURNSIZET( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNLEFT( libandria4_newstreams_result1, size_t, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT1_RETURNERR( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNRIGHT( libandria4_newstreams_result1, libandria4_newstreams_err, val )
	
	LIBANDRIA4_MONAD_MAYBE_BUILDTYPE(
		libandria4_newstreams_result2,
			libandria4_newstreams_err
	);
	#define LIBANDRIA4_NEWSTREAMS_RESULT2_BUILDJUST( val ) \
		LIBANDRIA4_MONAD_MAYBE_BUILDJUST( libandria4_newstreams_result2, libandria4_newstreams_err, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT2_BUILDNOTHING( ... ) \
		LIBANDRIA4_MONAD_MAYBE_BUILDNOTHING( libandria4_newstreams_result2, libandria4_newstreams_err )
	#define LIBANDRIA4_NEWSTREAMS_RESULT2_RETURNJUST( val ) \
		LIBANDRIA4_MONAD_MAYBE_RETURNLEFT( libandria4_newstreams_result2, libandria4_newstreams_err, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT2_RETURNNOTHING( ... ) \
		LIBANDRIA4_MONAD_MAYBE_RETURNRIGHT( libandria4_newstreams_result2, libandria4_newstreams_err )
	
	LIBANDRIA4_MONAD_EITHER_BUILDTYPE(
		libandria4_newstreams_result3,
			char,
			libandria4_newstreams_err
	);
	#define LIBANDRIA4_NEWSTREAMS_RESULT3_BUILDCHAR( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDLEFT( libandria4_newstreams_result3, char, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT3_BUILDERR( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDRIGHT( libandria4_newstreams_result3, libandria4_newstreams_err, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT3_RETURNCHAR( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNLEFT( libandria4_newstreams_result3, char, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT3_RETURNERR( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNRIGHT( libandria4_newstreams_result3, libandria4_newstreams_err, val )
	
	LIBANDRIA4_MONAD_EITHER_BUILDTYPE(
		libandria4_newstreams_result4,
			intmax_t,
			libandria4_newstreams_err
	);
	#define LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDINT( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDLEFT( libandria4_newstreams_result4, intmax_t, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( val ) \
		LIBANDRIA4_MONAD_EITHER_BUILDRIGHT( libandria4_newstreams_result4, libandria4_newstreams_err, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT4_RETURNINT( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNLEFT( libandria4_newstreams_result4, intmax_t, val )
	#define LIBANDRIA4_NEWSTREAMS_RESULT4_RETURNERR( val ) \
		LIBANDRIA4_MONAD_EITHER_RETURNRIGHT( libandria4_newstreams_result4, libandria4_newstreams_err, val )
	
	
	LIBANDRIA4_MONAD_BITUPLIC_BUILDTYPE(
		libandria4_newstreams_bituplic1,
			libandria4_newstreams_result1,
			libandria4_FILE_redirection
	);
	#define LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTRIGHT( \
			libandria4_newstreams_bituplic1, \
			libandria4_newstreams_result1, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTBOTH( \
			libandria4_newstreams_bituplic1, \
			libandria4_newstreams_result1, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP1_RETURNSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNRIGHT( \
			libandria4_newstreams_bituplic1, \
			libandria4_newstreams_result1, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP1_RETURNBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNBOTH( \
			libandria4_newstreams_bituplic1, \
			libandria4_newstreams_result1, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	
	LIBANDRIA4_MONAD_BITUPLIC_BUILDTYPE(
		libandria4_newstreams_bituplic2,
			libandria4_newstreams_err,
			libandria4_FILE_redirection
	);
	#define LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTRIGHT( \
			libandria4_newstreams_bituplic2, \
			libandria4_newstreams_err, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTBOTH( \
			libandria4_newstreams_bituplic2, \
			libandria4_newstreams_err, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP2_RETURNSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNRIGHT( \
			libandria4_newstreams_bituplic2, \
			libandria4_newstreams_err, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP2_RETURNBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNBOTH( \
			libandria4_newstreams_bituplic2, \
			libandria4_newstreams_err, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	
	LIBANDRIA4_MONAD_BITUPLIC_BUILDTYPE(
		libandria4_newstreams_bituplic3,
			libandria4_newstreams_result3,
			libandria4_FILE_redirection
	);
	#define LIBANDRIA4_NEWSTREAMS_BITUP3_BUILDJUSTSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTRIGHT( \
			libandria4_newstreams_bituplic3, \
			libandria4_newstreams_result3, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP3_BUILDJUSTBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTBOTH( \
			libandria4_newstreams_bituplic3, \
			libandria4_newstreams_result3, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP3_RETURNSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNRIGHT( \
			libandria4_newstreams_bituplic3, \
			libandria4_newstreams_result3, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP3_RETURNBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNBOTH( \
			libandria4_newstreams_bituplic3, \
			libandria4_newstreams_result3, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	
	LIBANDRIA4_MONAD_BITUPLIC_BUILDTYPE(
		libandria4_newstreams_bituplic4,
			libandria4_newstreams_result4,
			libandria4_FILE_redirection
	);
	#define LIBANDRIA4_NEWSTREAMS_BITUP4_BUILDJUSTSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTRIGHT( \
			libandria4_newstreams_bituplic4, \
			libandria4_newstreams_result4, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP4_BUILDJUSTBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_BUILDJUSTBOTH( \
			libandria4_newstreams_bituplic4, \
			libandria4_newstreams_result4, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNSTREAM( strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNRIGHT( \
			libandria4_newstreams_bituplic4, \
			libandria4_newstreams_result4, \
			libandria4_FILE_redirection, \
			strmptr )
	#define LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH( reslt, strmptr ) \
		LIBANDRIA4_MONAD_BITUPLIC_RETURNBOTH( \
			libandria4_newstreams_bituplic4, \
			libandria4_newstreams_result4, \
			libandria4_FILE_redirection, \
			reslt, strmptr )
	
	
	
	/* End the separate type definitions file, switch back to the */
	/*  primary new-streams file. */
	
	
	
	/* Things that won't be supported: */
		/* Directories */
			/* That's another layer's job. */
		/* char* setlocale (int category, const char* locale); */
			/* Need three wrappers, two providing default behaviors ("C" verses system-current). */
		/* string.h */
			/* Need LOTS of wrappers. */
		/*
				void* bsearch
				(
					const void* key, const void* base,
					size_t num, size_t size,
					int (*compar)(const void*,const void*)
				);
			and
				void qsort
				(
					void* base, size_t num, size_t size,
					int (*compar)(const void*,const void*)
				);
		*/
			/* Only noted because I need to make a wrapper... elsewhere. */
		/*
				char* asctime( const struct tm * timeptr );
			and
				char* ctime( const time_t * timer );
			and
				size_t strftime( char* ptr, size_t maxsize, const char* format,  const struct tm* timeptr );
		*/
			/* Only noted because I need to make a wrapper... elsewhere. */
		/* char* getenv (const char* name); */
			/* Only noted because I need to make a wrapper... elsewhere. */
		/* FILE * fopen ( const char * filename, const char * mode ); */
			/* This is probably not appropriate for this system. */
		/* reopen( ) */
			/* That's another layer's job. */
		/* int remove ( const char * filename ); */
			/* That's another layer's job. */
		/* int rename ( const char * oldname, const char * newname ); */
			/* That's another layer's job. */
		/* FILE * tmpfile ( void ); */
			/* That's another layer's job. */
		/* char * tmpnam ( char * str ); */
			/* That's another layer's job. */
		/* void setbuf ( FILE * stream, char * buffer ); & friend(s). */
			/* "Somebody else's problem", aka "make the caller do it". */
		/* int ungetc ( int character, FILE * stream ); */
			/* As setbuf(), but probably a wrapper in specific. */
	struct libandria4_FILE_substream_vtable
	{
		void (*attending)( uintptr_t *count );
		void (*neglecting)( uintptr_t *count );
		
		/* printf() will be supported by discrete external function: it's a big job, */
		/*  and should only been done once. Same for scanf(). */
		
		int (*is_eof)( void* /* FILE* */ );
			/* If there isn't an error, then it MIGHT still indicate eof. */
		libandria4_newstreams_result2 (*get_error)( void* /* FILE* */ );
		
		libandria4_newstreams_bituplic2 (*clear_err)( void* /* FILE* */ );
		
		
			/* For "Reference point" use SEEK_SET, SEEK_CUR, or SEEK_END, all from stdio.h */
		libandria4_newstreams_bituplic4 (*tell)( void* /* FILE* */, int /* Reference point. */ );
		libandria4_newstreams_bituplic2 (*seek)( void* /* FILE* */, intmax_t, int /* Reference point. */ );
		
		libandria4_newstreams_bituplic2 (*rewind)( void* /* FILE* */ );
		
		libandria4_newstreams_bituplic2 (*flush)( void* /* FILE* */ );
		
		
		libandria4_newstreams_bituplic3 (*get_c)( void* /* FILE* */ );
		libandria4_newstreams_bituplic1 (*put_c)( void* /* FILE* */, char );
		
		libandria4_newstreams_bituplic1
			(*get_s)
			( void* /* FILE* */, /* pascalarray< char >* */, size_t /* offset */ );
		libandria4_newstreams_bituplic1
			(*put_s)
			( void* /* FILE* */, /* pascalarray< char >* */, size_t /* offset */ );
		
		libandria4_newstreams_bituplic1
			(*block_read)
			( void* /* FILE* */, void* /* buffer */, size_t /* size */, size_t /* count */ );
		libandria4_newstreams_bituplic1
			(*block_write)
			( void* /* FILE* */, void* /* buffer */, size_t /* size */, size_t /* count */ );
		
			/* See LIBANDRIA4_NEWSTREAMS_ONDIE() for the cannonical approach to */
			/*  this return value... but feel free to do otherwise if it makes */
			/*  sense for your case. */
		void (*close)( void* /* FILE* */ );
	};
	
	
		/* The ondie handler is vitally important, and needs to interplay with */
		/*  the rest of this system. See libandria4_FILE_tracker_initialize()'s */
		/*  note. */
		/* Note that we SHOULD give this a better name later. */
		/* The first argument will be ->aux, the second will be ->data, but */
		/*  we're storing the FILE pointer in aux and the virtual table in val, */
		/*  so this is actually correct. */
		/* ??? ERROR IN *_ONDIE()!!! Look at the next to last line... WHERE is */
		/*  strmptr coming from? It should redirect to a "permanantly EOF" */
		/*  libandria4_FILE_substream*, so we need that */
		/*  libandria4_FILE_substream{} in turn to exist... and it doesn't, so */
		/*  it needs to be written. ??? */
		/* Note that the return value actually never gets used. */
	#define LIBANDRIA4_NEWSTREAMS_ONATTEND( tracked, file_p, vtab_p ) \
		( ( ( vtab_p ) && (vtab_p)->attending ) \
			? ( (vtab_p)->attending( &( (tracked)->ref_count ) ) ) )
	#define LIBANDRIA4_NEWSTREAMS_ONNEGLECT( tracked, file_p, vtab_p ) \
		( ( ( vtab_p ) && (vtab_p)->neglecting ) \
			? ( (vtab_p)->neglecting( &( (tracked)->ref_count ) ) ) )
	#define LIBANDRIA4_NEWSTREAMS_ONDIE( file_p, vtab_p ) \
		( ( ( vtab_p ) && (vtab_p)->close ) \
			? ( (vtab_p)->close( (file_p) ) ) )
		/* We want to just use malloc() & friends. */
	LIBANDRIA4_MONAD_REFPOINTER_DEFINE_STDIMPL(
			libandria4_FILE_tracker,
				libandria4_FILE_substream_vtable*,
				
				onattend, onneglect,
				LIBANDRIA4_NEWSTREAMS_ONDIE
		);
	
	extern libandria4_FILE_substream lib4_FILE_EOFsubstream;
	
	
	
	/* Below this should definitively be a .c file. */
	
	
	
		/* Complete. Note that THE POINTER ITSELF is null. */
	int libandria4_FILE_tracker_initialize_null( libandria4_FILE_tracker *trk )
	{
		if( trk )
		{
			return( LIBANDRIA4_MONAD_REFPOINTER_EXPRINIT_NULL( libandria4_FILE_tracker, *trk ) );
		}
		
		return( -1 );
	}
	static void libandria4_FILE_tracker_initialize_badalloc
	(
		void*, /* "this" pointer. */
		
		libandria4_FILE_tracker_counttype**,
			libandria4_FILE_substream_vtable*,
			void* /* FILE* */
	)
	{
		/* Do nothing, but we REALLY SHOULD log an error. */
		
		return;
	}
		/* Complete? */
	int libandria4_FILE_tracker_initialize( libandria4_FILE_tracker *trk,  FILE *f )
	{
		if( trk )
		{
			if( !libandria4_FILE_tracker_initialize_null( trk ) )
			{
				return( -2 );
			}
	/* Signature:  void (*onfull)( libandria4_FILE_file**,  FILE*, void* /* aux */ ) */
#define libandria4_FILE_tracker_initialize_ONFULL( ctr_ptr, vtab_ptr, f_p ) \
	( ( (vtab_ptr) != &lib4_FILE_vtab ? return( -3 ) : 1 ) \
		, ( (f_p) != f ? return( -4 ) : 1 ) \
		, return( 2 ) )
			
			static void *badalloc_data = (void*)0;
			LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYINIT(
				libandria4_FILE_tracker, *trk, &lib4_FILE_vtab, (void*)f,
				libandria4_FILE_tracker_initialize_ONFULL,
				libandria4_FILE_tracker_initialize_badalloc, badalloc_data );
			
			return( 1 );
		}
		
		return( -1 );
	}
		/* The "event handlers" need to be set. */
	int libandria4_FILE_tracker_redirect( libandria4_FILE_tracker *tracker, libandria4_FILE_tracker *donor )
	{
		if( tracker & donor )
		{
			LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYSET(
				libandria4_FILE_tracker, var, valptr,
						/* These five need to actually be set to something. */
					??? failneglect, failattend, succneglect, succattend, ondead ???
			);
			
			return( 1 );
		}
		
		return( -1 );
	}
		/* This looks complete? */
		/* Complete, but pointless. Build some more-proper wrappers. */
	int libandria4_FILE_tracker_apply
	(
		libandria4_FILE_tracker *trk,
		int *res,
		
			/* The argument in the va_list* will be the relevant FILE*. */
		int (*operation)( void*, va_list* ),
		void *op_data,
		
			/* The argument in the va_list* will be the provided */
			/*  libandria4_FILE_tracker{} BY VALUE. */
		int (*on_null)( void*, va_list* ),
		void *null_data
	)
	{
		if( trk && operation && on_null )
		{
				/* The value of "a" just doesn't matter. */
			int a;
			libandria4_op_indirfunc_int_voidp_valist_data functor1, functor2;
			int (*LIBANDRIA4_OP_runable1)( void *dat_, ... ) =
				&libandria4_op_indirfunc_int_voidp;
			int (*LIBANDRIA4_OP_runable2)( void *dat_, ... ) =
				&libandria4_op_indirfunc_int_voidp;
			void *LIBANDRIA4_OP_runabledata1, *LIBANDRIA4_OP_runabledata2;
			
			LIBANDRIA4_OP_runabledata1 = (void*)&functor1;
			functor1.func = operation;
			functor1.data = op_data;
			
			LIBANDRIA4_OP_runabledata2 = (void*)&functor2;
			functor2.func = on_null;
			functor2.data = null_data;
			
			
			int res_ =
				LIBANDRIA4_MONAD_REFPOINTER_EXPRAPPLY(
					*trk,
						LIBANDRIA4_OP_RUNifABLE1_ELSEa,
						LIBANDRIA4_OP_RUNifABLE2_ELSEa
				);
			if( res )
			{
				*res = res_;
			}
			
			
			return( 1 );
		}
		
		return( -1 );
	}
		/* Is this complete? Are those LIBANDRIA4_NULL_MACRO references both appropriate? */
	int libandria4_FILE_tracker_deinitialize
	(
		libandria4_FILE_tracker *trk,
		
		/* Both of these function pointers can be null if desired. */
			/* Just ignore the va_list*, there won't be any provided arguments. */
		void (*on_failedrelease)( void*, va_list* ),
		void *failedrelease_data
	)
	{
		if( trk )
		{
				/* The value of "a" just doesn't matter. */
			int a;
			libandria4_op_indirfunc_int_voidp_valist_data functor1, functor2;
			int (*LIBANDRIA4_OP_runable1)( void *dat_, ... ) =
				&libandria4_op_indirfunc_int_voidp;
			int (*LIBANDRIA4_OP_runable2)( void *dat_, ... ) =
				&libandria4_op_indirfunc_int_voidp;
			void *LIBANDRIA4_OP_runabledata1, *LIBANDRIA4_OP_runabledata2;
			
			LIBANDRIA4_OP_runabledata1 = (void*)&functor1;
			functor1.func = on_failedrelease;
			functor1.data = failedrelease_data;
			
			LIBANDRIA4_MONAD_REFPOINTER_WRAPPED_BODYDEINIT
			(
				libandria4_FILE_tracker, *trk,
					LIBANDRIA4_OP_RUNifABLE1_ELSEa, /* failneglect */
					LIBANDRIA4_NULL_MACRO, /* succneglect */
					LIBANDRIA4_NULL_MACRO /* ondead */
			);
			
			return( 1 );
		}
		
		return( -1 );
	}
	LIBANDRIA4_MONAD_REFPOINTER_DEFINE_WRAPPEDDECL(
		libandria4_FILE_tracker,
			libandria4_FILE_substream_vtable*
	);










/* Virtual-table implementations below. */
	
	/* Require <errno.h> */
	/* ??? Warning! Go back through and add code to check for null pointers! ??? */
	
	static void libandria4_FILE_tracker_commonreferencing( uintptr_t *count )
	{
			/* Just do nothing. */
		return;
	}
		/* These are only used for stuff that MUST NOT participate in normal */
		/*  memory allocationsw, because it's allocated during compile-time */
		/*  instead of run-time. */
	static void libandria4_FILE_tracker_deathlessattending( uintptr_t *count )
	{
		if( count )
		{
			--( *count );
		}
	}
	static void libandria4_FILE_tracker_deathlessneglecting( uintptr_t *count )
	{
		if( count )
		{
			++( *count );
		}
	}
	
	static int libandria4_FILE_tracker_feof( void *f )
	{
		return( feof( (FILE*)f ) );
	}
	static int libandria4_FILE_tracker_deathlessEOFfeof( void *f )
	{
		return( EOF );
	}
	static libandria4_newstreams_result2 libandria4_FILE_tracker_geterror( void *f )
	{
		int tmperr = errno;
		errno = 0;
			int res = ferror( (FILE*)f );
			if( errno != 0 )
			{
				???
			}
		errno = tmperr;
		
		if( res )
		{
			LIBANDRIA4_NEWSTREAMS_RESULT2_RETURNJUST( res );
		}
		
		LIBANDRIA4_NEWSTREAMS_RESULT2_RETURNNOTHING();
	}
	static libandria4_newstreams_result2 libandria4_FILE_tracker_deathlessEOFgeterror( void *f )
	{
		LIBANDRIA4_NEWSTREAMS_RESULT2_RETURNJUST( LIBANDRIA4_NEWSTREAMS_EOF );
	}
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_clearerr( void *f )
	{
		libandria4_newstreams_bituplic2 ret =
			LIBANDRIA4_MONAD_BITUP2_BUILDJUSTSTREAM( ??? strmptr ??? );
		
		int tmperr = errno;
		errno = 0;
			clearerr( (FILE*)f );
			if( errno != 0 )
			{
				int tmp = errno;
				ret =
					LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
						tmp,
						LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
					);
			}
		errno = tmperr;
		
		return( ret );
	}
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_deathlessEOFclearerr( void *f )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_EOF,
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic4 libandria4_FILE_tracker_tell( void* f, int refpt )
	{
		if( refpt != SEEK_SET )
		{
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( ??? val ??? ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
		}
		
		long pos = ftell( (FILE*)f );
		if( pos >= 0 )
		{
			if( pos > INTMAX_MAX )
			{
				/* But how??? */
				
				LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
					LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( ??? ), /* libandria4_newstreams_err */
					LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
				);
			}
			
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDINT( pos ), /* intmax_t */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
			
		} else {
			
			int tmp = errno;
			errno = 0;
			
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( tmp ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
		}
	}
	static libandria4_newstreams_bituplic4 libandria4_FILE_tracker_deathlessEOFtell( void* f, int refpt )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	static libandria4_newstreams_bituplic4 libandria4_FILE_tracker_seek( void* f, intmax_t off, int refpt )
	{
		if( off > LONG_MAX )
		{
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( ??? val ??? ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
		}
		switch( refpt )
		{
			case SEEK_SET:   case SEEK_CUR:   case SEEK_END:
					/* Same handling for all three. */
				break;
			default:
				{
					LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
						LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( ??? val ??? ), /* libandria4_newstreams_err */
						LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
					);
				}
		}
		
		int res = fseek( (FILE*)f, off, refpt );
		if( res != 0 )
		{
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR( res ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
			
		} else {
			
			LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDINT( pos ), /* intmax_t */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
		}
	}
	static libandria4_newstreams_bituplic4 libandria4_FILE_tracker_deathlessEOFseek( void* f, intmax_t off, int refpt )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP4_RETURNBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT4_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ), /* libandria4_newstreams_err */
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_rewind( void* f )
	{
		libandria4_newstreams_bituplic2 ret =
			LIBANDRIA4_MONAD_BITUP2_BUILDJUSTSTREAM( ??? strmptr ??? );
		
		int tmp = errno;
		errno = 0;
			rewind( (FILE*)f );
			if( errno != 0 )
			{
				int tmp = errno;
				ret =
					LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
						tmp,
						LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
					);
			}
		errno = tmp;
		
		return( ret );
	}
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_deathlessEOFrewind( void* f )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_EOF,
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_flush( void* f )
	{
		libandria4_newstreams_bituplic2 ret =
			LIBANDRIA4_MONAD_BITUP2_BUILDJUSTSTREAM( ??? strmptr ??? );
		
		int res = fflush( (FILE*)f );
		if( res != 0 )
		{
			if( res != EOF )
			{
				ret =
					LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
						??? err ???,
						LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
					);
				
			} else {
				
				ret =
					LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
						LIBANDRIA4_NEWSTREAMS_EOF,
						LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
					);
			}
		}
		
		return( ret );
	}
	static libandria4_newstreams_bituplic2 libandria4_FILE_tracker_deathlessEOFflush( void* f )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP2_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_EOF,
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic3 libandria4_FILE_tracker_getc( void* f )
	{
		libandria4_newstreams_bituplic3 ret =
			LIBANDRIA4_MONAD_BITUP3_BUILDJUSTSTREAM( ??? strmptr ??? );
		
		int res = fgetc( (FILE*)f );
		if( res == EOF )
		{
			ret =
				LIBANDRIA4_NEWSTREAMS_BITUP3_BUILDJUSTBOTH(
					LIBANDRIA4_NEWSTREAMS_RESULT3_BUILDERR(
						LIBANDRIA4_NEWSTREAMS_EOF ),
					LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
				);
			
		} else {
			
			ret =
				LIBANDRIA4_NEWSTREAMS_BITUP3_BUILDJUSTBOTH(
					LIBANDRIA4_NEWSTREAMS_RESULT3_BUILDCHAR( ??? ),
					LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
				);
		}
		
		return( ret );
	}
	static libandria4_newstreams_bituplic3 libandria4_FILE_tracker_deathlessEOFgetc( void* f )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP3_RETURNJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT3_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_putc( void* f, char ch )
	{
		libandria4_newstreams_bituplic1 ret =
			LIBANDRIA4_MONAD_BITUP1_BUILDJUSTSTREAM(
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT() );
		
		int res = fputc( ch, (FILE*)f );
		if( res == EOF )
		{
			ret =
				LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
					LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
						LIBANDRIA4_NEWSTREAMS_EOF ),
					LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
				);
			
		} else {
			
			ret =
				LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
					LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDSIZET( 1 ),
					LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
				);
		}
		
		return( ret );
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_deathlessEOFputc( void* f, char ch )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_gets
		( void* (FILE*), /* pascalarray< char >* */, size_t offset )
	{
		/* Read "manually". */
		
		???
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_deathlessEOFgets
		( void* (FILE*), /* pascalarray< char >* */, size_t offset )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_puts
		( void* (FILE*), /* pascalarray< char >* */, size_t offset )
	{
		/* Write "manually". */
		
		???
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_deathlessEOFputs
		( void* (FILE*), /* pascalarray< char >* */, size_t offset )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_block_read
		( void* f, void* buffer, size_t size, size_t count )
	{
		size_t read = fread( buffer, size, count, (FILE*)f );
		LIBANDRIA4_NEWSTREAMS_BITUP1_RETURNBOTH(
			LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDSIZET( read ),
			LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
		);
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_deathlessEOFblock_read
		( void* f, void* buffer, size_t size, size_t count )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_block_write
		( void* f, void* buffer, size_t size, size_t count )
	{
		size_t read = fwrite( buffer, size, count, (FILE*)f );
		LIBANDRIA4_NEWSTREAMS_BITUP1_RETURNBOTH(
			LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDSIZET( read ),
			LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
		);
	}
	static libandria4_newstreams_bituplic1 libandria4_FILE_tracker_deathlessEOFblock_write
		( void* f, void* buffer, size_t size, size_t count )
	{
		LIBANDRIA4_NEWSTREAMS_BITUP1_BUILDJUSTBOTH(
				LIBANDRIA4_NEWSTREAMS_RESULT1_BUILDERR(
					LIBANDRIA4_NEWSTREAMS_EOF ),
				LIBANDRIA4_FILE_REDIRECTION_TOCURRENT()
			);
	}
	
		/* This is not directly involved in redirections. */
		/* Note: need a "permanently EOF" stream to redirect to! */
	static void libandria4_FILE_tracker_commonclose( void *f )
	{
		int res = fclose( (FILE*)f );
		if( res != EOF )
		{
			???
			
		} else {
			
			???
		}
	}
	static void libandria4_FILE_tracker_deathlessclose( void *f )
	{
			/* There's nothing to do. */
		return;
	}
	
	
		/* ??? Should this be a global instead? ??? */
	static libandria4_FILE_substream_vtable
		lib4_FILE_vtab =
		{
			&libandria4_FILE_tracker_commonreferencing,
			&libandria4_FILE_tracker_commonreferencing,
			
			&libandria4_FILE_tracker_feof,
				/* If there isn't an error, then it MIGHT still indicate eof. */
			&libandria4_FILE_tracker_geterror,
			
			&libandria4_FILE_tracker_clearerr,
			
			
			&libandria4_FILE_tracker_tell,
			&libandria4_FILE_tracker_seek,
			
			&libandria4_FILE_tracker_rewind,
			
			&libandria4_FILE_tracker_flush,
			
			
			&libandria4_FILE_tracker_getc,
			&libandria4_FILE_tracker_putc,
			
			&libandria4_FILE_tracker_gets,
			&libandria4_FILE_tracker_puts,
			
			&libandria4_FILE_tracker_block_read,
			&libandria4_FILE_tracker_block_write,
			
			&libandria4_FILE_tracker_commonclose
		};
	
	
	
		/* ??? Should this be a global instead? ??? */
	static libandria4_FILE_substream_vtable
		lib4_FILE_EOFvtab =
		{
			&libandria4_FILE_tracker_deathlessattending,
			&libandria4_FILE_tracker_deathlessneglecting,
			
			&libandria4_FILE_tracker_deathlessEOFfeof,
				/* If there isn't an error, then it MIGHT still indicate eof. */
			&libandria4_FILE_tracker_deathlessEOFgeterror,
			
			&libandria4_FILE_tracker_deathlessEOFclearerr,
			
			
			&libandria4_FILE_tracker_deathlessEOFtell,
			&libandria4_FILE_tracker_deathlessEOFseek,
			
			&libandria4_FILE_tracker_deathlessEOFrewind,
			
			&libandria4_FILE_tracker_deathlessEOFflush,
			
			
			&libandria4_FILE_tracker_deathlessEOFgetc,
			&libandria4_FILE_tracker_deathlessEOFputc,
			
			&libandria4_FILE_tracker_deathlessEOFgets,
			&libandria4_FILE_tracker_deathlessEOFputs,
			
			&libandria4_FILE_tracker_deathlessEOFblock_read,
			&libandria4_FILE_tracker_deathlessEOFblock_write,
			
			&libandria4_FILE_tracker_deathlessclose
		};
	libandria4_FILE_substream lib4_FILE_EOFsubstream =
		{
				/* ref_count */
			1,
				/* auxiliary, currently FILE*, should be the virtual table. */
			(void*)0,
				/* val, should be FILE*, currently the vtab. */
			(libandria4_FILE_substream_vtable*)&lib4_FILE_EOFvtab
		};
